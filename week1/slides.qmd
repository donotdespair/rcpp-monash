---
title: ETC4500/ETC5450 Advanced&nbsp;R&nbsp;programming
author: "Week 1: Foundations of R programming"
format:
  beamer:
    aspectratio: 169
    fontsize: "14pt,t"
    section-titles: false
    knitr:
      opts_chunk:
        dev: "cairo_pdf"
    fig-width: 7.5
    fig-height: 3.5
    include-in-header: ../header.tex
    keep_tex: yes
---

```{r setup, include=FALSE}
source(here::here("setup.R"))
source(here::here("course_info.R"))
```

## Outline

\vspace*{0.4cm}
\tableofcontents

# Names and values

## Quiz
\fontsize{12.5}{13}\sf

1.  Given the following data frame, how do I create a new column called "3"
    that contains the sum of `1` and `2`? You may only use `$`, not `[[`.
    What makes `1`, `2`, and `3` challenging as variable names?

    ```{r}
    df <- data.frame(runif(3), runif(3))
    names(df) <- c(1, 2)
    ```

1.  In the following code, how much memory does `y` occupy?

    ```{r}
    x <- runif(1e6)
    y <- list(x, x, x)
    ```

1.  On which line does `a` get copied in the following example?

    ```{r}
    a <- c(1, 5, 3, 2)
    b <- a
    b[[1]] <- 10
    ```


## Binding basics

```{r bind1}
x <- c(1, 2, 3)
```

\vspace*{0.2cm}

* Creates an object, a vector of values, `c(1, 2, 3)`.
* Binds that object to a name, `x`.
* A name is a reference (or pointer) to a value.

\placefig{8}{1.4}{width=3.5cm, height=20cm}{../diagrams/name-value/binding-1.png}\pause\vspace*{1cm}

```{r bind2, dependson = "bind1"}
y <- x
```

* Binds the same object to a new name, `y`.

\only<2>{\placefig{8}{5}{width=3.5cm, height=20cm}{../diagrams/name-value/binding-2.png}}

\vspace*{10cm}

## Binding basics

```{r bind3, dependson = "bind2"}
library(lobstr)
obj_addr(x)
obj_addr(y)
```

These identifiers are long, and change every time you restart R.

## Syntactic names {#non-syntactic}

A __syntactic__ name:

* must consist of letters, digits, `.` and `_`
* can't begin with `_`, or a digit, or a `.` followed by a digit
* can't be a __reserved word__ like `TRUE`, `NULL`, `if`, and `function`

```{r, eval = FALSE}
_abc <- 1
#> Error: unexpected input in "_"

if <- 10
#> Error: unexpected assignment in "if <-"
```

It's possible to override these rules using backticks.

```{r}
`_abc` <- 1
`_abc`
```

## Exercises

1.  Explain the relationship between `a`, `b`, `c` and `d` in the following
    code:

    ```{r}
    a <- 1:10
    b <- a
    c <- b
    d <- 1:10
    ```

2.  What rules does `make.names()` use to convert non-syntactic names into
    syntactic ones?

3.  Why is `.123e1` not a syntactic name?

## Copy-on-modify

Consider the following code. It binds `x` and `y` to the same underlying value, then modifies `y`.

```{r}
x <- c(1, 2, 3)
y <- x

y[[3]] <- 4
x
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("../diagrams/name-value/binding-3.png")
```

## `tracemem()`

You can see when an object gets copied using `tracemem()`. \fontsize{9}{9}\sf

```{r trace1}
x <- c(1, 2, 3)
tracemem(x)
```

```{r trace2, dependson = "trace1"}
y <- x
y[[3]] <- 4L
```

```{r trace3, dependson = "trace2"}
y[[3]] <- 5L
untracemem(x)
```

## Modify-in-place

If an object has a single name bound to it, R will modify it in place:

```{r}
v <- c(1, 2, 3)
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("../diagrams/name-value/v-inplace-1.png")
```

```{r}
v[[3]] <- 4
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("../diagrams/name-value/v-inplace-2.png")
```

## Function calls

The same rules for copying also apply to function calls. \fontsize{9}{9}\sf

```{r}
f <- function(a) {
  a
}

x <- c(1, 2, 3)
tracemem(x)
z <- f(x)
# there's no copy here!
untracemem(x)
```

\only<2>{\placefig{8}{4}{width=7.5cm, height=20cm}{../diagrams/name-value/binding-f1.png}}


## Lists {#list-references}

Lists store references to their elements,\newline
not the elements themselves.

```{r list1}
l1 <- list(1, 2, 3)
```

\vspace*{1.4cm}

\placefig{11}{2.5}{width=3cm, height=20cm}{../diagrams/name-value/list.png}\pause

```{r list2, dependson = "list1"}
l2 <- l1
```

\vspace*{1.4cm}

\only<2->{\placefig{11}{4.5}{width=3cm, height=20cm}{../diagrams/name-value/l-modify-1.png}\pause}

```{r list3, dependson = "list2"}
l2[[3]] <- 4
```

\vspace*{1.5cm}

\only<3>{\placefig{11}{6.5}{width=3cm, height=20cm}{../diagrams/name-value/l-modify-2.png}}

\vspace*{10cm}

## Data frames {#df-modify}

Data frames are lists of vectors.

```{r}
d1 <- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))
```

\vspace{1.5cm}
\placefig{9.8}{.7}{height=3.4cm, width=20cm}{../diagrams/name-value/dataframe.png}\pause

Modifying a column:

```{r}
d2 <- d1
d2[, 2] <- d2[, 2] * 2
```

\only<2>{\placefig{9.8}{4.2}{height=4.7cm, width=20cm}{../diagrams/name-value/d-modify-c.png}}

\vspace*{10cm}

## Data frames {#df-modify}

Data frames are lists of vectors.

```{r}
d1 <- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))
```
\vspace{1.5cm}
\placefig{9.8}{0.7}{height=3.4cm, width=20cm}{../diagrams/name-value/dataframe.png}

Modifying a row:

```{r}
d3 <- d1
d3[1, ] <- d3[1, ] * 3
```

\placefig{9.8}{4.2}{height=3.4cm, width=20cm}{../diagrams/name-value/d-modify-r.png}

\vspace*{10cm}

## Character vectors
\fontsize{13}{14}\sf

```{r}
x <- c("a", "a", "abc", "d")
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("../diagrams/name-value/character.png")
```

* Not quite!
* R actually uses a __global string pool__ where each element is a pointer to a string in the pool

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("../diagrams/name-value/character-2.png")
```

## Exercises

1.  Why is `tracemem(1:10)` not useful?

1.  Explain why `tracemem()` shows two copies when you run this code.

    ```{r, results = FALSE}
    x <- c(1L, 2L, 3L)
    tracemem(x)

    x[[3]] <- 4
    ```

## Exercises

3.  Sketch out the relationship between the following objects:

    ```{r}
    a <- 1:10
    b <- list(a, a)
    c <- list(b, a, 1:10)
    ```

4.  What happens when you run this code?

    ```{r}
    x <- list(1:10)
    x[[2]] <- x
    ```

    Draw a picture.

## Object size

`lobstr::obj_size()` gives the size of an object in memory.
\fontsize{11}{11}\sf

```{r}
obj_size(ggplot2::diamonds)
banana <- "bananas bananas bananas"
obj_size(banana)
obj_size(rep(banana, 100))
```

## Object size

```{r}
x <- runif(1e6)
obj_size(x)
y <- list(x, x, x)
obj_size(y)
obj_size(x, y)
```

## ALTREP

```{r}
obj_size(1:3)
obj_size(1:1e3)
obj_size(1:1e6)
```

## Exercises

Predict the output of the following code:

```{r}
#| eval: false
a <- runif(1e6)
obj_size(a)

b <- list(a, a)
obj_size(b)
obj_size(a, b)

b[[1]][[1]] <- 10
obj_size(b)
obj_size(a, b)

b[[2]][[1]] <- 10
obj_size(b)
obj_size(a, b)
```

## For loops

Loops have a reputation for being slow, but often that is caused by iterations creating copies.
\fontsize{8}{8}\sf\vspace*{-0.2cm}

```{r}
#| output: false
x <- data.frame(matrix(runif(3 * 1e4), ncol = 3))
medians <- vapply(x, median, numeric(1))
tracemem(x)
```

\vspace*{-0.3cm}

```{r}
for (i in seq_along(medians)) {
  x[[i]] <- x[[i]] - medians[[i]]
}
```

\fontsize{13}{15}\sf

* Each iteration copies the data frame two times!

\vspace*{10cm}

## For loops

The same problem but with a list.
\fontsize{8}{8}\sf\vspace*{-0.2cm}

```{r}
#| output: false
y <- as.list(x)
tracemem(y)
```

\vspace*{-0.3cm}

```{r}
for (i in 1:3) {
  y[[i]] <- y[[i]] - medians[[i]]
}
```

\fontsize{13}{15}\sf

* Only one copy created

\vspace*{10cm}

## Unbinding and the garbage collector {#gc}

\placefig{10}{1.5}{width=3.5cm, height=20cm}{../diagrams/name-value/unbinding-1.png}
\only<2->{\placefig{10}{3.5}{width=3.5cm, height=20cm}{../diagrams/name-value/unbinding-2.png}}
\only<3>{\placefig{10}{6.5}{width=3.5cm, height=20cm}{../diagrams/name-value/unbinding-3.png}}


```{r}
x <- 1:3
```

\vspace*{1.5cm}\pause

```{r}
x <- 2:4
```

\vspace*{1.5cm}\pause

```{r}
rm(x)
```

\vspace*{10cm}

## Garbage collection

* Garbage collection (GC) frees up memory by deleting R objects that are no longer used, and by requesting more memory from the operating system if needed.
* R traces every object that's reachable from the global environment (recursively).
* GC runs automatically whenever R needs more memory to create a new object.
* You can force garbage collection by calling `gc()`. But it's *never* necessary.

# Vectors

## Vectors

\placefig{10}{0.1}{width=3.5cm, height=20cm}{../diagrams/vectors/summary-tree.png}\vspace*{0.2cm}

* Vectors come in two flavours: atomic vectors and lists
* For atomic vectors, all elements must have same type
* For lists, elements can have different types
* `NULL` is like a generic zero length vector
* Scalars are just vectors of length 1
* Every vector can also have __attributes__: a named list of arbitrary metadata.
* The __dimension__ attribute turns vectors into matrices and arrays.
* The __class__ attribute powers the S3 object system.

## Atomic vectors

* Four primary types of atomic vectors: logical, integer, double, and character (which contains strings).
* Collectively integer and double vectors are known as numeric vectors
* Two rare types: complex and raw.

\vspace*{10cm}

\placefig{9}{3.8}{width=6cm, height=20cm}{../diagrams/vectors/summary-tree-atomic.png}

## Scalars

* Logicals: `TRUE` or `FALSE`, or abbreviated (`T` or `F`).

* Doubles: decimal (`0.1234`), scientific (`1.23e4`), or hexadecimal (`0xcafe`). Special values: `Inf`, `-Inf`, and `NaN` (not a number).

* Integers: `1234L`, `1e4L`, or `0xcafeL`. Can not contain fractional values.

* Strings: `"hi"` or `'bye'`. Special characters are escaped with `\`.

## Making longer vectors with `c()` {#atomic-constructing}

Use `c()` to create longer vectors from shorter ones.

```{r}
lgl_var <- c(TRUE, FALSE)
int_var <- c(1L, 6L, 10L)
dbl_var <- c(1, 2.5, 4.5)
chr_var <- c("these are", "some strings")
```
When the inputs are atomic vectors,\newline `c()` always flattens.

```{r}
c(c(1, 2), c(3, 4))
```

\placefig{9.8}{2.5}{width=6cm, height=20cm}{../diagrams/vectors/atomic.png}

## Types and length
\fontsize{13}{13}\sf

You can determine the type of a vector with `typeof()` and its length with `length()`.

\fontsize{10}{10}\sf


```{r}
typeof(lgl_var)
typeof(int_var)
typeof(dbl_var)
typeof(chr_var)
```

## Missing values

Most computations involving a missing value will return another missing value.

\fontsize{10}{10}\sf

```{r}
NA > 5
10 * NA
!NA
```

## Missing values

Exceptions:

\fontsize{10}{10}\sf

```{r}
NA ^ 0
NA | TRUE
NA & FALSE
```

## Missing values

Use `is.na()` to check for missingness

\fontsize{10}{10}\sf

```{r}
x <- c(NA, 5, NA, 10)
x == NA
is.na(x)
```

\fontsize{13}{14}\sf

There are actually four missing values:  `NA` (logical), `NA_integer_` (integer), `NA_real_` (double), and `NA_character_` (character).

## Coercion

* For atomic vectors, all elements must be the same type.
* When you combine different types they are __coerced__ in a fixed order: character → double → integer → logical.

\fontsize{10}{10}\sf

```{r}
str(c("a", 1))
x <- c(FALSE, FALSE, TRUE)
as.numeric(x)
sum(x)
mean(x)
as.integer(c("1", "1.5", "a"))
```

## Exercises

1. Predict the output of the following:

```{r, eval=FALSE}
c(1, FALSE)
c("a", 1)
c(TRUE, 1L)
```

1. Why is `1 == "1"` true? Why is `-1 < FALSE` true? Why is `"one" < 2` false?

1. Why is the default missing value, `NA`, a logical vector? What's special
   about logical vectors? (Hint: think about `c(FALSE, NA_character_)`.)

1. Precisely what do `is.atomic()`, `is.numeric()`, and `is.vector()` test for?


## Getting and setting

* You can think of attributes as name-value pairs that attach metadata to an object.
* Individual attributes can be retrieved and modified with `attr()`, or retrieved en masse with `attributes()`, and set en masse with `structure()`.

\fontsize{10}{10}\sf

```{r}
a <- 1:3
attr(a, "x") <- "abcdef"
attr(a, "x")
```

## Getting and setting
\fontsize{10}{10}\sf

```{r}
attr(a, "y") <- 4:6
str(attributes(a))

# Or equivalently
a <- structure(
  1:3,
  x = "abcdef",
  y = 4:6
)
str(attributes(a))
```

\placefig{1}{10}{width=3.5cm, height=20cm}{../diagrams/vectors/attr.png}

## Names {#attr-names}

You can name a vector in three ways:

```{r}
# When creating it:
x <- c(a = 1, b = 2, c = 3)

# By assigning a character vector to names()
x <- 1:3
names(x) <- c("a", "b", "c")

# Inline, with setNames():
x <- setNames(1:3, c("a", "b", "c"))
```

## Names

* Avoid using `attr(x, "names")` as it requires more typing and is less readable than `names(x)`.
* You can remove names from a vector by using `x <- unname(x)` or `names(x) <- NULL`.


## Dimensions {#attr-dims}

* Adding a `dim` attribute to a vector allows it to behave like a 2-dimensional __matrix__ or a multi-dimensional __array__.
* You can create matrices and arrays with `matrix()` and `array()`, or by using the assignment form of `dim()`:

```{r}
# Two scalar arguments specify row and column sizes
x <- matrix(1:6, nrow = 2, ncol = 3)
x

# One vector argument to describe all dimensions
y <- array(1:12, c(2, 3, 2))
y

# You can also modify an object in place by setting dim()
z <- 1:6
dim(z) <- c(3, 2)
z
```

## Dimensions

Many of the functions for working with vectors have generalisations for matrices and arrays:

| Vector            | Matrix                     | Array            |
|-------------------|----------------------------|------------------|
| `names()`         | `rownames()`, `colnames()` | `dimnames()`     |
| `length()`        | `nrow()`, `ncol()`         | `dim()`          |
| `c()`             | `rbind()`, `cbind()`       | `abind::abind()` |
| ---               | `t()`                      | `aperm()`        |
| `is.null(dim(x))` | `is.matrix()`              | `is.array()`     |

## Dimensions

* A vector without a `dim` attribute set is often thought of as 1-dimensional, but actually has `NULL` dimensions.
* You also can have matrices with a single row or single column, or arrays with a single dimension.
* Use `str()` to reveal the differences.

```{r}
str(1:3)                   # 1d vector
str(matrix(1:3, ncol = 1)) # column vector
str(matrix(1:3, nrow = 1)) # row vector
str(array(1:3, 3))         # "array" vector
```

## Exercises

1.  How is `setNames()` implemented? How is `unname()` implemented?
    Read the source code.

1.  What does `dim()` return when applied to a 1-dimensional vector?
    When might you use `NROW()` or `NCOL()`?

1.  How would you describe the following three objects? What makes them
    different from `1:5`?

    ```{r}
    x1 <- array(1:5, c(1, 1, 5))
    x2 <- array(1:5, c(1, 5, 1))
    x3 <- array(1:5, c(5, 1, 1))
    ```

1.  An early draft used this code to illustrate `structure()`:

    ```{r}
    structure(1:5, comment = "my attribute")
    ```

    But when you print that object you don't see the comment attribute.
    Why? Is the attribute missing, or is there something else special about
    it? (Hint: try using help.)

## S3 atomic vectors

* One of the most important vector attributes is `class`, which underlies the S3 object system.
* Having a class attribute turns an object into an __S3 object__, which means it will behave differently from a regular vector when passed to a __generic__ function.
* Every S3 object is built on top of a base type, and often stores additional information in other attributes.

In this section, we'll discuss four important S3 vectors used in base R:

* Categorical data, where values come from a fixed set of levels recorded in
  __factor__ vectors.

* Dates (with day resolution), which are recorded in __Date__ vectors.

* Date-times (with second or sub-second resolution), which are stored in
  __POSIXct__ vectors.

* Durations, which are stored in __difftime__ vectors.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("../diagrams/vectors/summary-tree-s3-1.png")
```

## Factors

A factor is a vector that can contain only predefined values. It is used to store categorical data. Factors are built on top of an integer vector with two attributes: a `class`, "factor", which makes it behave differently from regular integer vectors, and `levels`, which defines the set of allowed values.

```{r}
x <- factor(c("a", "b", "b", "a"))
x

typeof(x)
attributes(x)
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("../diagrams/vectors/factor.png")
```

Factors are useful when you know the set of possible values but they're not all present in a given dataset. In contrast to a character vector, when you tabulate a factor you'll get counts of all categories, even unobserved ones:

```{r}
sex_char <- c("m", "m", "m")
sex_factor <- factor(sex_char, levels = c("m", "f"))

table(sex_char)
table(sex_factor)
```

__Ordered__ factors are a minor variation of factors. In general, they behave like regular factors, but the order of the levels is meaningful (low, medium, high) (a property that is automatically leveraged by some modelling and visualisation functions).

```{r}
grade <- ordered(c("b", "b", "a", "c"), levels = c("c", "b", "a"))
grade
```

In base R you tend to encounter factors very frequently because many base R functions (like `read.csv()` and `data.frame()`) automatically convert character vectors to factors. This is suboptimal because there's no way for those functions to know the set of all possible levels or their correct order: the levels are a property of theory or experimental design, not of the data. Instead, use the argument `stringsAsFactors = FALSE` to suppress this behaviour, and then manually convert character vectors to factors using your knowledge of the "theoretical" data. To learn about the historical context of this behaviour, I recommend [_stringsAsFactors: An unauthorized
biography_](https://simplystatistics.org/posts/2015-07-24-stringsasfactors-an-unauthorized-biography) by Roger Peng, and [_stringsAsFactors =
\<sigh\>_](http://notstatschat.tumblr.com/post/124987394001/stringsasfactors-sigh) by Thomas Lumley.


While factors look like (and often behave like) character vectors, they are built on top of integers. So be careful when treating them like strings. Some string methods (like `gsub()` and `grepl()`) will automatically coerce factors to strings,  others (like `nchar()`) will throw an error, and still others will (like `c()`) use the underlying integer values. For this reason, it's usually best to explicitly convert factors to character vectors if you need string-like behaviour.

## Dates

Date vectors are built on top of double vectors. They have class "Date" and no other attributes:

```{r}
today <- Sys.Date()

typeof(today)
attributes(today)
```

The value of the double (which can be seen by stripping the class), represents the number of days since 1970-01-01[^epoch]:

```{r}
date <- as.Date("1970-02-01")
unclass(date)
```

[^epoch]: This special date is known as the Unix Epoch.

## Date-times

Base R provides two ways of storing date-time information, POSIXct, and POSIXlt. These are admittedly odd names: "POSIX" is short for Portable Operating System Interface, which is a family of cross-platform standards. "ct" stands for calendar time (the `time_t` type in C), and "lt" for local time (the `struct tm` type in C). Here we'll focus on `POSIXct`, because it's the simplest, is built on top of an atomic vector, and is most appropriate for use in data frames. POSIXct vectors are built on top of double vectors, where the value represents the number of seconds since 1970-01-01.

```{r}
now_ct <- as.POSIXct("2018-08-01 22:00", tz = "UTC")
now_ct

typeof(now_ct)
attributes(now_ct)
```

The `tzone` attribute controls only how the date-time is formatted; it does not control the instant of time represented by the vector. Note that the time is not printed if it is midnight.

```{r}
structure(now_ct, tzone = "Asia/Tokyo")
structure(now_ct, tzone = "America/New_York")
structure(now_ct, tzone = "Australia/Lord_Howe")
structure(now_ct, tzone = "Europe/Paris")
```

## Durations

Durations, which represent the amount of time between pairs of dates or date-times, are stored in difftimes. Difftimes are built on top of doubles, and have a `units` attribute that determines how the integer should be interpreted:

```{r}
one_week_1 <- as.difftime(1, units = "weeks")
one_week_1

typeof(one_week_1)
attributes(one_week_1)

one_week_2 <- as.difftime(7, units = "days")
one_week_2

typeof(one_week_2)
attributes(one_week_2)
```

## Exercises

1.  What sort of object does `table()` return? What is its type? What
    attributes does it have? How does the dimensionality change as you
    tabulate more variables?

1.  What happens to a factor when you modify its levels?

    ```{r, results = FALSE}
    f1 <- factor(letters)
    levels(f1) <- rev(levels(f1))
    ```

1.  What does this code do? How do `f2` and `f3` differ from `f1`?

    ```{r, results = FALSE}
    f2 <- rev(factor(letters))

    f3 <- factor(letters, levels = rev(letters))
    ```


## Lists

Lists are a step up in complexity from atomic vectors: each element can be any type, not just vectors. Technically speaking, each element of a list is actually the same type because, as you saw in Section \@ref(list-references), each element is really a _reference_ to another object, which can be any type.

## Creating {#list-creating}

You construct lists with `list()`:

```{r}
l1 <- list(
  1:3,
  "a",
  c(TRUE, FALSE, TRUE),
  c(2.3, 5.9)
)

typeof(l1)

str(l1)
```

Because the elements of a list are references, creating a list does not involve copying the components into the list. For this reason, the total size of a list might be smaller than you might expect.

```{r}
lobstr::obj_size(mtcars)

l2 <- list(mtcars, mtcars, mtcars, mtcars)
lobstr::obj_size(l2)
```

Lists can contain complex objects so it's not possible to pick a single visual style that works for every list. Generally I'll draw lists like vectors, using colour to remind you of the hierarchy.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("../diagrams/vectors/list.png")
```

Lists are sometimes called __recursive__ vectors because a list can contain other lists. This makes them fundamentally different from atomic vectors.

```{r}
l3 <- list(list(list(1)))
str(l3)
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("../diagrams/vectors/list-recursive.png")
```

`c()` will combine several lists into one. If given a combination of atomic vectors and lists, `c()` will coerce the vectors to lists before combining them. Compare the results of `list()` and `c()`:

```{r}
l4 <- list(list(1, 2), c(3, 4))
l5 <- c(list(1, 2), c(3, 4))
str(l4)
str(l5)
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("../diagrams/vectors/list-c.png")
```

## Testing and coercion {#list-types}

The `typeof()` a list is `list`. You can test for a list with `is.list()`, and coerce to a list with `as.list()`.

```{r}
list(1:3)
as.list(1:3)
```

You can turn a list into an atomic vector with `unlist()`. The rules for the resulting type are complex, not well documented, and not always equivalent to what you'd get with `c()`.

## Matrices and arrays {#list-array}

With atomic vectors, the dimension attribute is commonly used to create matrices. With lists, the dimension attribute can be used to create list-matrices or list-arrays:

```{r}
l <- list(1:3, "a", TRUE, 1.0)
dim(l) <- c(2, 2)
l

l[[1, 1]]
```

These data structures are relatively esoteric but they can be useful if you want to arrange objects in a grid-like structure. For example, if you're running models on a spatio-temporal grid, it might be more intuitive to store the models in a 3D array that matches the grid structure.

## Exercises

1.  List all the ways that a list differs from an atomic vector.

1.  Why do you need to use `unlist()` to convert a list to an
    atomic vector? Why doesn't `as.vector()` work?

1.  Compare and contrast `c()` and `unlist()` when combining a
    date and date-time into a single vector.

## Data frames and tibbles {#tibble}

The two most important S3 vectors built on top of lists are data frames and tibbles.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("../diagrams/vectors/summary-tree-s3-2.png")
```

If you do data analysis in R, you're going to be using data frames. A data frame is a named list of vectors with attributes for (column) `names`, `row.names`[^rownames], and its class, "data.frame":

```{r}
df1 <- data.frame(x = 1:3, y = letters[1:3])
typeof(df1)

attributes(df1)
```

In contrast to a regular list, a data frame has an additional constraint: the length of each of its vectors must be the same. This gives data frames their rectangular structure and explains why they share the properties of both matrices and lists:

* A data frame has `rownames()`[^row.names] and `colnames()`. The `names()`
  of a data frame are the column names.

* A data frame has `nrow()` rows and `ncol()` columns. The `length()` of a
  data frame gives the number of columns.

[^row.names]: Technically, you are encouraged to use `row.names()`, not `rownames()` with data frames, but this distinction is rarely important.

Data frames are one of the biggest and most important ideas in R, and one of the things that make R different from other programming languages. However, in the over 20 years since their creation, the ways that people use R have changed, and some of the design decisions that made sense at the time data frames were created now cause frustration.

This frustration lead to the creation of the tibble [@tibble], a modern reimagining of the data frame. Tibbles are designed to be (as much as possible) drop-in replacements for data frames that fix those frustrations. A concise, and fun, way to summarise the main differences is that tibbles are lazy and surly: they do less and complain more. You'll see what that means as you work through this section.

Tibbles are provided by the tibble package and share the same structure as data frames. The only difference is that the class vector is longer, and includes `tbl_df`. This allows tibbles to behave differently in the key ways which we'll discuss below.

```{r}
library(tibble)

df2 <- tibble(x = 1:3, y = letters[1:3])
typeof(df2)

attributes(df2)
```

## Creating {#df-create}

You create a data frame by supplying name-vector pairs to `data.frame()`:

```{r}
df <- data.frame(
  x = 1:3,
  y = c("a", "b", "c")
)
str(df)
```

If you are using a version of R before 4.0.0, beware of the default conversion of strings to factors. Use `stringsAsFactors = FALSE` to suppress this and keep character vectors as character vectors:

```{r}
df1 <- data.frame(
  x = 1:3,
  y = c("a", "b", "c"),
  stringsAsFactors = FALSE
)
str(df1)
```

Creating a tibble is similar to creating a data frame. The difference between the two is that tibbles never coerce their input (this is one feature that makes them lazy):

```{r}
df2 <- tibble(
  x = 1:3,
  y = c("a", "b", "c")
)
str(df2)
```

Additionally, while data frames automatically transform non-syntactic names (unless `check.names = FALSE`), tibbles do not (although they do print non-syntactic names surrounded by `` ` ``).

```{r}
names(data.frame(`1` = 1))

names(tibble(`1` = 1))
```

While every element of a data frame (or tibble) must have the same length, both `data.frame()` and `tibble()` will recycle shorter inputs. However, while data frames automatically recycle columns that are an integer multiple of the longest column, tibbles will only recycle vectors of length one.

```{r, error = TRUE}
data.frame(x = 1:4, y = 1:2)
data.frame(x = 1:4, y = 1:3)

tibble(x = 1:4, y = 1)
tibble(x = 1:4, y = 1:2)
```

There is one final difference: `tibble()` allows you to refer to variables created during construction:

```{r}
tibble(
  x = 1:3,
  y = x * 2
)
```

(Inputs are evaluated left-to-right.)

When drawing data frames and tibbles, rather than focussing on the implementation details, i.e. the attributes:

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("../diagrams/vectors/data-frame-1.png")
```

I'll draw them the same way as a named list, but arrange them to emphasise their columnar structure.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("../diagrams/vectors/data-frame-2.png")
```

## Row names {#rownames}

Data frames allow you to label each row with a name, a character vector containing only unique values:

```{r}
df3 <- data.frame(
  age = c(35, 27, 18),
  hair = c("blond", "brown", "black"),
  row.names = c("Bob", "Susan", "Sam")
)
df3
```

You can get and set row names with `rownames()`, and you can use them to subset rows:

```{r}
rownames(df3)

df3["Bob", ]
```

Row names arise naturally if you think of data frames as 2D structures like matrices: columns (variables) have names so rows (observations) should too. Most matrices are numeric, so having a place to store character labels is important. But this analogy to matrices is misleading because matrices possess an important property that data frames do not: they are transposable. In matrices the rows and columns are interchangeable, and transposing a matrix gives you another matrix (transposing again gives you the original matrix). With data frames, however, the rows and columns are not interchangeable: the transpose of a data frame is not a data frame.

There are three reasons why row names are undesirable:

*   Metadata is data, so storing it in a different way to the rest of the
    data is fundamentally a bad idea. It also means that you need to learn
    a new set of tools to work with row names; you can't use what you already
    know about manipulating columns.

*   Row names are a poor abstraction for labelling rows because they only work
    when a row can be identified by a single string. This fails in many cases,
    for example when you want to identify a row by a non-character vector
    (e.g. a time point), or with multiple vectors (e.g. position, encoded by
    latitude and longitude).

*   Row names must be unique, so any duplication of rows (e.g. from
    bootstrapping) will create new row names. If you want to match rows from
    before and after the transformation, you'll need to perform complicated
    string surgery.

    ```{r}
    df3[c(1, 1, 1), ]
    ```

For these reasons, tibbles do not support row names. Instead the tibble package provides tools to easily convert row names into a regular column with either `rownames_to_column()`, or the `rownames` argument in `as_tibble()`:

```{r}
as_tibble(df3, rownames = "name")
```

## Printing

One of the most obvious differences between tibbles and data frames is how they print. I assume that you're already familiar with how data frames are printed, so here I'll highlight some of the biggest differences using an example dataset included in the dplyr package:

```{r}
dplyr::starwars
```

* Tibbles only show the first 10 rows and all the columns that will fit on
  screen. Additional columns are shown at the bottom.

* Each column is labelled with its type, abbreviated to three or four letters.

* Wide columns are truncated to avoid having a single long string occupy an
  entire row. (This is still a work in progress: it's a tricky tradeoff between
  showing as many columns as possible and showing columns in their entirety.)

* When used in console environments that support it, colour is used judiciously
  to highlight important information, and de-emphasise supplemental details.

## Testing and coercing {#df-test-coerce}

To check if an object is a data frame or tibble, use `is.data.frame()`:

```{r}
is.data.frame(df1)
is.data.frame(df2)
```

Typically, it should not matter if you have a tibble or data frame, but if you need to be certain, use `is_tibble()`:

```{r}
is_tibble(df1)
is_tibble(df2)
```

You can coerce an object to a data frame with `as.data.frame()` or to a tibble with `as_tibble()`.

## List columns

Since a data frame is a list of vectors, it is possible for a data frame to have a column that is a list. This is very useful because a list can contain any other object: this means you can put any object in a data frame. This allows you to keep related objects together in a row, no matter how complex the individual objects are. You can see an application of this in the "Many Models" chapter of _R for Data Science_, <http://r4ds.had.co.nz/many-models.html>.

List-columns are allowed in data frames but you have to do a little extra work by either adding the list-column after creation or wrapping the list in `I()`[^identity].

[^identity]: `I()` is short for identity and is often used to indicate that an input should be left as is, and not automatically transformed.

```{r}
df <- data.frame(x = 1:3)
df$y <- list(1:2, 1:3, 1:4)

data.frame(
  x = 1:3,
  y = I(list(1:2, 1:3, 1:4))
)
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("../diagrams/vectors/data-frame-list.png")
```

List columns are easier to use with tibbles because they can be directly included inside `tibble()` and they will be printed tidily:

```{r}
tibble(
  x = 1:3,
  y = list(1:2, 1:3, 1:4)
)
```

## Matrix and data frame columns

As long as the number of rows matches the data frame, it's also possible to have a matrix or array as a column of a data frame. (This requires a slight extension to our definition of a data frame: it's not the `length()` of each column that must be equal, but the `NROW()`.) As for list-columns, you must either add it after creation, or wrap it in `I()`.

```{r}
dfm <- data.frame(
  x = 1:3 * 10
)
dfm$y <- matrix(1:9, nrow = 3)
dfm$z <- data.frame(a = 3:1, b = letters[1:3], stringsAsFactors = FALSE)

str(dfm)
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("../diagrams/vectors/data-frame-matrix.png")
```

Matrix and data frame columns require a little caution. Many functions that work with data frames assume that all columns are vectors. Also, the printed display can be confusing.

```{r}
dfm[1, ]
```

## Exercises

1.  Can you have a data frame with zero rows? What about zero columns?

1.  What happens if you attempt to set rownames that are not unique?

1.  If `df` is a data frame, what can you say about `t(df)`, and `t(t(df))`?
    Perform some experiments, making sure to try different column types.

1.  What does `as.matrix()` do when applied to a data frame with
    columns of different types? How does it differ from `data.matrix()`?

## `NULL`

To finish up this chapter, I want to talk about one final important data structure that's closely related to vectors: `NULL`. `NULL` is special because it has a unique type, is always length zero, and can't have any attributes:

```{r, error = TRUE}
typeof(NULL)

length(NULL)

x <- NULL
attr(x, "y") <- 1
```

You can test for `NULL`s with `is.null()`:

```{r}
is.null(NULL)
```

There are two common uses of `NULL`:

*   To represent an empty vector (a vector of length zero) of arbitrary type.
    For example, if you use `c()` but don't include any arguments, you get
    `NULL`, and concatenating `NULL` to a vector will leave it unchanged:

    ```{r}
    c()
    ```

*   To represent an absent vector. For example, `NULL` is often used as a
    default function argument, when the argument is optional but the default
    value requires some computation (see Section \@ref(missing-arguments) for
    more on this). Contrast this with `NA` which is used to indicate that
    an _element_ of a vector is absent.

If you're familiar with SQL, you'll know about relational `NULL` and might expect it to be the same as R's. However, the database `NULL` is actually equivalent to R's `NA`.

## Quiz answers {#data-structure-answers}

1.  The four common types of atomic vector are logical, integer, double
    and character. The two rarer types are complex and raw.

1.  Attributes allow you to associate arbitrary additional metadata to
    any object. You can get and set individual attributes with `attr(x, "y")`
    and `attr(x, "y") <- value`; or you can get and set all attributes at once
    with `attributes()`.

1.  The elements of a list can be any type (even a list); the elements of
    an atomic vector are all of the same type. Similarly, every element of
    a matrix must be the same type; in a data frame, different columns can have
    different types.

1.  You can make a list-array by assigning dimensions to a list. You can
    make a matrix a column of a data frame with `df$x <- matrix()`, or by
    using `I()` when creating a new data frame `data.frame(x = I(matrix()))`.

1.  Tibbles have an enhanced print method, never coerce strings to
    factors, and provide stricter subsetting methods.

# Subsetting

# Control flow

# Functions

# Environments

# Conditions
