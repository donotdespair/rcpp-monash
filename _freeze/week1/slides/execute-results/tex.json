{
  "hash": "41edcc0e1860216b62f7cb7a1c77d853",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: ETC4500/ETC5450 Advanced&nbsp;R&nbsp;programming\nauthor: \"Week 1: Foundations of R programming\"\nformat:\n  presentation-beamer:\n    fontsize: \"14pt,t\"\n    section-titles: false\n    knitr:\n      opts_chunk:\n        dev: \"cairo_pdf\"\n    fig-width: 7.5\n    fig-height: 3.5\n    include-in-header: ../header.tex\n    keep-tex: false\n---\n\n\n\n## Outline\n\n\\vspace*{0.4cm}\n\\tableofcontents\n\n## First things first\n\n### Expectations\n\n* You know R and RStudio\n* You have a basic understanding of programming (for loops, if statements, functions)\n* You can use Git and GitHub (https://happygitwithr.com)\n\n### Unit resources\n\n* Everything on **https://arp.numbat.space**\n* Assignments submitted on Github Classroom\n* Discussion on Ed\n\n## GitHub\n\n* Use your monash edu address.\n* Apply to GitHub Global Campus as a student (https://education.github.com).\n* Gives you free access to private repos and GitHub Copilot.\n* Add GitHub Copilot to RStudio settings.\n\n# Introduction to R\n## R history\n\n* S (1976, Chambers, Becker and Wilks; Bell Labs, USA)\n* S-PLUS (1988, Doug Martin; Uni of Washington, USA)\n* R (1993, Ihaka and Gentleman; Uni of Auckland, NZ)\n\n\\pause\\vspace*{0.4cm}\n\n### R influenced by\n\n* Lisp (functional programming, environments, dynamic typing)\n* Scheme (functional programming, lexical scoping)\n* S and S-PLUS (syntax)\n\n## Why R?\n\n* Free, open source, and on every major platform.\n* A diverse and welcoming community\n* A massive set of packages, often cutting-edge.\n* Powerful communication tools (Shiny, Rmarkdown, \\rlap{quarto)}\n* RStudio IDE\n* Deep-seated language support for data analysis.\n* A strong foundation of functional programming.\n* Posit\n* Easy connection to high-performance programming languages\n  like C, Fortran, and C++.\n\n## R challenges\n\n* R users are not usually programmers. Most R code by ordinary users is not very elegant, fast, or easy to understand.\n* R users more focused on results than good software practices.\n* R packages are inconsistent in design.\n* R can be slow.\n\n# Names and values\n\n## Exercises\n\\fontsize{12.5}{13}\\sf\n\n1.  Given the following data frame, how do I create a new column called \"3\"\n    that contains the sum of `1` and `2`? You may only use `$`, not `[[`.\n    What makes `1`, `2`, and `3` challenging as variable names?\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df <- data.frame(runif(3), runif(3))\n    names(df) <- c(1, 2)\n    ```\n    :::\n\n2.  In the following code, how much memory does `y` occupy?\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- runif(1e6)\n    y <- list(x, x, x)\n    ```\n    :::\n\n3.  On which line does `a` get copied in the following example?\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    a <- c(1, 5, 3, 2)\n    b <- a\n    b[[1]] <- 10\n    ```\n    :::\n\n\n## Binding basics\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\n```\n:::\n\n\\vspace*{0.2cm}\n\n* Creates an object, a vector of values, `c(1, 2, 3)`.\n* Binds that object to a name, `x`.\n* A name is a reference (or pointer) to a value.\n\n\\placefig{8}{1.4}{width=3.5cm, height=20cm}{../diagrams/name-value/binding-1.png}\\pause\\vspace*{1cm}\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- x\n```\n:::\n\n* Binds the same object to a new name, `y`.\n\n\\only<2>{\\placefig{8}{5}{width=3.5cm, height=20cm}{../diagrams/name-value/binding-2.png}}\n\n\\vspace*{10cm}\n\n## Binding basics\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lobstr)\nobj_addr(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x598afe124d78\"\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_addr(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x598afe124d78\"\n```\n\n\n:::\n:::\n\nThese identifiers are long, and change every time you restart R.\n\n## Syntactic names {#non-syntactic}\n\\fontsize{13}{15}\\sf\n\nA __syntactic__ name:\n\n* must consist of letters, digits, `.` and `_`\n* can't begin with `_`, or a digit, or a `.` followed by a digit\n* can't be a __reserved word__ like `TRUE`, `NULL`, `if`, and `function`\n\n::: {.cell}\n\n```{.r .cell-code}\n_abc <- 1\n#> Error: unexpected input in \"_\"\n\nif <- 10\n#> Error: unexpected assignment in \"if <-\"\n```\n:::\n\n\\pause\n\nIt's possible to override these rules using backticks.\n\n::: {.cell}\n\n```{.r .cell-code}\n`_abc` <- 1\n`_abc`\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n## Copy-on-modify\n\nConsider the following code. It binds `x` and `y` to the same underlying value, then modifies `y`.\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\ny <- x\n```\n:::\n\n\\pause\\vspace*{1.5cm}\n\n::: {.cell}\n\n```{.r .cell-code}\ny[[3]] <- 4\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\\placefig{10}{2.7}{width=3.5cm, height=20cm}{../diagrams/name-value/binding-2.png}\n\n\\only<2>{\\placefig{10}{6}{width=3.5cm, height=20cm}{../diagrams/name-value/binding-3.png}}\n\n## `tracemem()`\n\nYou can see when an object gets copied using `tracemem()`. \\fontsize{9}{9}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\ntracemem(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"<0x598afe30ce18>\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- x\ny[[3]] <- 4L\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntracemem[0x598afe30ce18 -> 0x598afe338338]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers <Anonymous> process_file <Anonymous> <Anonymous> execute .main \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ny[[3]] <- 5L\nuntracemem(x)\n```\n:::\n\n## Modify-in-place\n\nIf an object has a single name bound to it, R will modify it in place:\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- c(1, 2, 3)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](../diagrams/name-value/v-inplace-1.png){width=1.34in}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nv[[3]] <- 4\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](../diagrams/name-value/v-inplace-2.png){width=1.34in}\n:::\n:::\n\n## Function calls\n\nThe same rules for copying also apply to function calls. \\fontsize{9}{9}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(a) {\n  a\n}\n\nx <- c(1, 2, 3)\ntracemem(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"<0x598afe191178>\"\n```\n\n\n:::\n\n```{.r .cell-code}\nz <- f(x)\n# there's no copy here!\nuntracemem(x)\n```\n:::\n\n## Lists {#list-references}\n\nLists store references to their elements,\\newline\nnot the elements themselves.\n\n::: {.cell}\n\n```{.r .cell-code}\nl1 <- list(1, 2, 3)\n```\n:::\n\n\\vspace*{1.4cm}\n\n\\placefig{11}{2.5}{width=3cm, height=20cm}{../diagrams/name-value/list.png}\\pause\n\n::: {.cell}\n\n```{.r .cell-code}\nl2 <- l1\n```\n:::\n\n\\vspace*{1.4cm}\n\n\\only<2->{\\placefig{11}{4.5}{width=3cm, height=20cm}{../diagrams/name-value/l-modify-1.png}\\pause}\n\n::: {.cell}\n\n```{.r .cell-code}\nl2[[3]] <- 4\n```\n:::\n\n\\vspace*{1.5cm}\n\n\\only<3>{\\placefig{11}{6.5}{width=3cm, height=20cm}{../diagrams/name-value/l-modify-2.png}}\n\n\\vspace*{10cm}\n\n## Data frames {#df-modify}\n\nData frames are lists of vectors.\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 <- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\n```\n:::\n\n\\vspace{1.5cm}\n\\placefig{9.8}{.7}{height=3.4cm, width=20cm}{../diagrams/name-value/dataframe.png}\\pause\n\nModifying a column:\n\n::: {.cell}\n\n```{.r .cell-code}\nd2 <- d1\nd2[, 2] <- d2[, 2] * 2\n```\n:::\n\n\\only<2>{\\placefig{9.8}{4.2}{height=4.7cm, width=20cm}{../diagrams/name-value/d-modify-c.png}}\n\n\\vspace*{10cm}\n\n## Data frames\n\nData frames are lists of vectors.\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 <- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\n```\n:::\n\\vspace{1.5cm}\n\\placefig{9.8}{0.7}{height=3.4cm, width=20cm}{../diagrams/name-value/dataframe.png}\n\nModifying a row:\n\n::: {.cell}\n\n```{.r .cell-code}\nd3 <- d1\nd3[1, ] <- d3[1, ] * 3\n```\n:::\n\n\\placefig{9.8}{4.2}{height=3.4cm, width=20cm}{../diagrams/name-value/d-modify-r.png}\n\n\\vspace*{10cm}\n\n## Character vectors\n\\fontsize{13}{13.5}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"a\", \"a\", \"abc\", \"d\")\n```\n:::\n::: {.cell}\n::: {.cell-output-display}\n![](../diagrams/name-value/character.png){width=2.01in}\n:::\n:::\n\n* Not quite!\n* R actually uses a __global string pool__ where each element is a pointer to a string in the pool\n\n::: {.cell}\n::: {.cell-output-display}\n![](../diagrams/name-value/character-2.png){width=2.08in}\n:::\n:::\n## Object size\n\n`lobstr::obj_size()` gives the size of an object in memory.\n\\fontsize{11}{11}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nobj_size(ggplot2::diamonds)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3.46 MB\n```\n\n\n:::\n\n```{.r .cell-code}\nbanana <- \"bananas bananas bananas\"\nobj_size(banana)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n136 B\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(rep(banana, 100))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n928 B\n```\n\n\n:::\n:::\n\n## Object size\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- runif(1e6)\nobj_size(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n8.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\ny <- list(x, x, x)\nobj_size(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n8.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n8.00 MB\n```\n\n\n:::\n:::\n\n## ALTREP\n\n::: {.cell}\n\n```{.r .cell-code}\nobj_size(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n680 B\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(1:1e6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n680 B\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(c(1:1e6, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n8.00 MB\n```\n\n\n:::\n\n```{.r .cell-code}\nobj_size(2 * (1:1e6))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n8.00 MB\n```\n\n\n:::\n:::\n\n## For loops\n\nLoops have a reputation for being slow, but often that is caused by iterations creating copies.\n\\fontsize{9}{9}\\sf\\vspace*{-0.2cm}\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- data.frame(matrix(runif(3 * 1e4), ncol = 3))\nmedians <- vapply(x, median, numeric(1))\ntracemem(x)\n```\n:::\n\n\\vspace*{-0.3cm}\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in seq_along(medians)) {\n  x[[i]] <- x[[i]] - medians[[i]]\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntracemem[0x598afdf35af8 -> 0x598afb4663a8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers <Anonymous> process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x598afb4663a8 -> 0x598afb4662b8]: [[<-.data.frame [[<- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers <Anonymous> process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x598afb4662b8 -> 0x598afb466218]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers <Anonymous> process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x598afb466218 -> 0x598afb466128]: [[<-.data.frame [[<- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers <Anonymous> process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x598afb466128 -> 0x598afb466088]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers <Anonymous> process_file <Anonymous> <Anonymous> execute .main \ntracemem[0x598afb466088 -> 0x598afb465f98]: [[<-.data.frame [[<- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers <Anonymous> process_file <Anonymous> <Anonymous> execute .main \n```\n\n\n:::\n:::\n\n\\fontsize{13}{15}\\sf\n\n* Each iteration copies the data frame two times!\n\n\\vspace*{10cm}\n\n## For loops\n\nThe same problem but with a list.\n\\fontsize{9}{9}\\sf\\vspace*{-0.2cm}\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- as.list(x)\ntracemem(y)\n```\n:::\n\n\\vspace*{-0.3cm}\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:3) {\n  y[[i]] <- y[[i]] - medians[[i]]\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntracemem[0x598afc3267a8 -> 0x598afe193cf8]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts <Anonymous> evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers <Anonymous> process_file <Anonymous> <Anonymous> execute .main \n```\n\n\n:::\n:::\n\n\\fontsize{13}{15}\\sf\n\n* Only one copy created\n\n\\vspace*{10cm}\n\n\n## Don't allocate memory in a for loop\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# Allocating memory within the loop\nsystem.time(\n{\n  x <- NULL\n  for(i in seq(1e5)) {\n    x <- c(x, i)\n  }\n}\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n  9.865   0.099   9.978 \n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# Allocating memory before the loop\nsystem.time(\n{\n  x <- numeric(1e5)\n  for(i in seq(1e5)) {\n    x[i] <- i\n  }\n}\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n  0.009   0.000   0.009 \n```\n\n\n:::\n:::\n\n:::\n::::\n\n## Unbinding and the garbage collector {#gc}\n\n\\placefig{10}{1.5}{width=3.5cm, height=20cm}{../diagrams/name-value/unbinding-1.png}\n\\only<2->{\\placefig{10}{3.5}{width=3.5cm, height=20cm}{../diagrams/name-value/unbinding-2.png}}\n\\only<3>{\\placefig{10}{6.2}{width=3.5cm, height=20cm}{../diagrams/name-value/unbinding-3.png}}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:3\n```\n:::\n\n\\vspace*{1.5cm}\\pause\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2:4\n```\n:::\n\n\\vspace*{1.5cm}\\pause\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(x)\n```\n:::\n\n\\vspace*{10cm}\n\n## Garbage collection\n\n* Garbage collection (GC) frees up memory by deleting R objects that are no longer used, and by requesting more memory from the operating system if needed.\n* R traces every object that's reachable from the global environment (recursively).\n* GC runs automatically whenever R needs more memory to create a new object.\n* You can force garbage collection by calling `gc()`. But it's *never* necessary.\n\n# Vectors\n\n## Vectors\n\n\\placefig{10}{0.1}{width=3.5cm, height=20cm}{../diagrams/vectors/summary-tree.png}\\vspace*{0.2cm}\n\n* Vectors come in two flavours: atomic vectors and lists\n* For atomic vectors, all elements must have same type\n* For lists, elements can have different types\n* `NULL` is like a generic zero length vector\n* Scalars are just vectors of length 1\n* Every vector can also have __attributes__: a named list of arbitrary metadata.\n* The __dimension__ attribute turns vectors into matrices and arrays.\n* The __class__ attribute powers the S3 object system.\n\n## Atomic vectors\n\\vspace*{-0.2cm}\n\n* Four primary types of atomic vectors: logical, integer, double, and character (which contains strings).\n* Collectively integer and double vectors are known as numeric vectors\n* Two rare types:\n\n  * complex\n  * raw.\n\n\\vspace*{10cm}\n\n\\placefig{9}{3.8}{width=6cm, height=20cm}{../diagrams/vectors/summary-tree-atomic.png}\n\n## Scalars\n\n* Logicals: `TRUE` or `FALSE`, or abbreviated (`T` or `F`).\n\n* Doubles: decimal (`0.1234`), scientific (`1.23e4`), or hexadecimal (`0xcafe`). Special values: `Inf`, `-Inf`, and `NaN` (not a number).\n\n* Integers: `1234L`, `1e4L`, or `0xcafeL`. Can not contain fractional values.\n\n* Strings: `\"hi\"` or `'bye'`. Special characters are escaped with `\\`.\n\n## Making longer vectors with `c()` {#atomic-constructing}\n\nUse `c()` to create longer vectors from shorter ones.\n\n::: {.cell}\n\n```{.r .cell-code}\nlgl_var <- c(TRUE, FALSE)\nint_var <- c(1L, 6L, 10L)\ndbl_var <- c(1, 2.5, 4.5)\nchr_var <- c(\"these are\", \"some strings\")\n```\n:::\nWhen the inputs are atomic vectors,\\newline `c()` always flattens.\n\n::: {.cell}\n\n```{.r .cell-code}\nc(c(1, 2), c(3, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\n\\placefig{9.8}{2.5}{width=6cm, height=20cm}{../diagrams/vectors/atomic.png}\n\n## Types and length\n\\fontsize{13}{13}\\sf\n\nYou can determine the type of a vector with `typeof()` and its length with `length()`.\n\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(lgl_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(int_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(dbl_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(chr_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n## Missing values\n\nMost computations involving a missing value will return another missing value.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nNA > 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n10 * NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n!NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n## Missing values\n\nExceptions:\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nNA ^ 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nNA | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nNA & FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n## Missing values\n\nUse `is.na()` to check for missingness\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(NA, 5, NA, 10)\nx == NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA NA NA NA\n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\\fontsize{13}{14}\\sf\n\nThere are actually four missing values:  `NA` (logical), `NA_integer_` (integer), `NA_real_` (double), and `NA_character_` (character).\n\n## Coercion\n\\fontsize{13}{14}\\sf\\vspace*{-0.25cm}\n\n* For atomic vectors, all elements must be the same type.\n* When you combine different types they are __coerced__ in a fixed order: logical → integer → double → character.\n\n\\fontsize{10}{4}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(c(\"a\", 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n chr [1:2] \"a\" \"1\"\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- c(FALSE, FALSE, TRUE)\nas.numeric(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 0 1\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nas.integer(c(\"1\", \"1.5\", \"a\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  1 NA\n```\n\n\n:::\n:::\n\n## Exercises\n\n4.  Predict the output of the following:\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    c(1, FALSE)\n    c(\"a\", 1)\n    c(TRUE, 1L)\n    ```\n    :::\n\n5. Why is `1 == \"1\"` true? Why is `-1 < FALSE` true? Why is `\"one\" < 2` false?\n\n6. Why is the default missing value, `NA`, a logical vector? What's special\n   about logical vectors? (Hint: think about `c(FALSE, NA_character_)`.)\n\n## Getting and setting attributes\n\n* You can think of attributes as name-value pairs that attach metadata to an object.\n* Individual attributes can be retrieved and modified with `attr()`, or retrieved en masse with `attributes()`, and set en masse with `structure()`.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1:3\nattr(a, \"x\") <- \"abcdef\"\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\nattr(,\"x\")\n[1] \"abcdef\"\n```\n\n\n:::\n:::\n\n## Getting and setting attributes\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(a, \"y\") <- 4:6\nstr(attributes(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n```\n\n\n:::\n\n```{.r .cell-code}\n# Or equivalently\na <- structure(\n  1:3,\n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n```\n\n\n:::\n:::\n\n\\placefig{10}{1}{width=3.5cm, height=20cm}{../diagrams/vectors/attr.png}\n\n## Names {#attr-names}\n\n* Names are a type of attribute.\n* You can name a vector in three ways:\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\n# When creating it:\nx <- c(a = 1, b = 2, c = 3)\n\n# By assigning a character vector to names()\nx <- 1:3\nnames(x) <- c(\"a\", \"b\", \"c\")\n\n# Inline, with setNames():\nx <- setNames(1:3, c(\"a\", \"b\", \"c\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na b c \n1 2 3 \n```\n\n\n:::\n:::\n\n## Names\n\n* Avoid using `attr(x, \"names\")` as it requires more typing and is less readable than `names(x)`.\n* You can remove names from a vector by using\\newline `x <- unname(x)` or `names(x) <- NULL`.\n\n\n## Dimensions {#attr-dims}\n\n* Adding a `dim` attribute to a vector allows it to behave like a 2-dimensional __matrix__ or a multi-dimensional __array__.\n* You can create matrices and arrays with `matrix()` and `array()`, or by using the assignment form of `dim()`:\n\n::: {.cell}\n\n```{.r .cell-code}\n# Two scalar arguments specify row and column sizes\nx <- matrix(1:6, nrow = 2, ncol = 3)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n:::\n\n## Dimensions\n\n::: {.cell}\n\n```{.r .cell-code}\n# One vector argument to describe all dimensions\ny <- array(1:12, c(2, 3, 2))\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n```\n\n\n:::\n:::\n\n## Dimensions\n\n::: {.cell}\n\n```{.r .cell-code}\n# You can also modify an object in place by setting dim()\nz <- 1:6\ndim(z) <- c(3, 2)\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n\n\n:::\n:::\n\n## Exercises\n\n7. What does `dim()` return when applied to a 1-dimensional vector?\n8. When might you use `NROW()` or `NCOL()`?\n9. How would you describe the following three objects? What makes them different from `1:5`?\n\n   ::: {.cell}\n   \n   ```{.r .cell-code}\n   x1 <- array(1:5, c(1, 1, 5))\n   x2 <- array(1:5, c(1, 5, 1))\n   x3 <- array(1:5, c(5, 1, 1))\n   ```\n   :::\n\n## S3 atomic vectors\n\n* `class` is a vector attribute.\n* It turns object into __S3 object__.\n* Four important S3 vectors:\n\n  * **factor** vectors.\n  * **Date** vectors with day resolution.\n  * **POSIXct** vectors for date-times.\n  * **difftime** vectors for durations.\n\n\\placefig{10}{2}{width=6cm}{../diagrams/vectors/summary-tree-s3-1.png}\n\n## Factors\n\n* A vector that can contain only predefined values.\n* Used to store categorical data.\n* Built on top of an integer vector with two attributes: a `class`, \"factor\", and `levels`, which defines the set of allowed values.\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] a b b a\nLevels: a b\n```\n\n\n:::\n:::\n\n## Factors\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$levels\n[1] \"a\" \"b\"\n\n$class\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\\placefig{10}{2}{width=5cm,height=20cm}{../diagrams/vectors/factor.png}\n\n## Factors\n\n::: {.cell}\n\n```{.r .cell-code}\nsex_char <- c(\"m\", \"m\", \"m\")\nsex_factor <- factor(sex_char, levels = c(\"m\", \"f\"))\n\ntable(sex_char)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nsex_char\nm \n3 \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(sex_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nsex_factor\nm f \n3 0 \n```\n\n\n:::\n:::\n\n## Factors\n\n* Be careful: some functions convert factors to integers!\n* ggplot preserves ordering of levels in graphs -- useful to reorder panels or legends.\n* Ordered factors are useful when the order of levels is meaningful.\n\n::: {.cell}\n\n```{.r .cell-code}\ngrade <- ordered(c(\"b\", \"b\", \"a\", \"c\"), levels = c(\"c\", \"b\", \"a\"))\ngrade\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] b b a c\nLevels: c < b < a\n```\n\n\n:::\n:::\n\n## Dates\n\n* Date vectors are built on top of double vectors.\n* Class \"Date\" with no other attributes:\n\n::: {.cell}\n\n```{.r .cell-code}\ntoday <- Sys.Date()\n\ntypeof(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$class\n[1] \"Date\"\n```\n\n\n:::\n:::\n\n## Dates\n\nThe value of the double (which can be seen by stripping the class), represents the number of days since 1970-01-01 (the \"Unix Epoch\").\n\n::: {.cell}\n\n```{.r .cell-code}\ndate <- as.Date(\"1970-02-01\")\nunclass(date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31\n```\n\n\n:::\n:::\n\n## Date-times\n\n* Base R provides two ways of storing date-time information, POSIXct, and POSIXlt.\n* \"POSIX\" is short for Portable Operating System Interface\n* \"ct\" stands for calendar time; \"lt\" for local time\n* POSIXct vectors are built on top of double vectors, where the value represents the number of seconds since 1970-01-01.\n\n::: {.cell}\n\n```{.r .cell-code}\nnow_ct <- as.POSIXct(\"2018-08-01 22:00\", tz = \"UTC\")\nnow_ct\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-08-01 22:00:00 UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(now_ct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(now_ct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$class\n[1] \"POSIXct\" \"POSIXt\" \n\n$tzone\n[1] \"UTC\"\n```\n\n\n:::\n:::\n\n## Date-times\n\nThe `tzone` attribute controls only how the date-time is formatted; it does not control the instant of time represented by the vector. Note that the time is not printed if it is midnight.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nstructure(now_ct, tzone = \"Asia/Tokyo\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-08-02 07:00:00 JST\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstructure(now_ct, tzone = \"America/New_York\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-08-01 18:00:00 EDT\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstructure(now_ct, tzone = \"Australia/Lord_Howe\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-08-02 08:30:00 +1030\"\n```\n\n\n:::\n:::\n\n\n## Exercises\n\n10. What sort of object does `table()` return? What is its type? What\n    attributes does it have? How does the dimensionality change as you\n    tabulate more variables?\n\n11. What happens to a factor when you modify its levels?\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    f1 <- factor(letters)\n    levels(f1) <- rev(levels(f1))\n    ```\n    :::\n\n12. What does this code do? How do `f2` and `f3` differ from `f1`?\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    f2 <- rev(factor(letters))\n    f3 <- factor(letters, levels = rev(letters))\n    ```\n    :::\n\n\n## Lists\n\n* More complex than atomic vectors\n* Elements are *references* to objects of any type\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nl1 <- list(\n  1:3, \"a\", c(TRUE, FALSE, TRUE), c(2.3, 5.9)\n)\ntypeof(l1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(l1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ : int [1:3] 1 2 3\n $ : chr \"a\"\n $ : logi [1:3] TRUE FALSE TRUE\n $ : num [1:2] 2.3 5.9\n```\n\n\n:::\n:::\n\n\\placefig{10}{3.5}{width=5cm,height=20cm}{../diagrams/vectors/list.png}\n\n## Lists\n\n* Lists can be recursive:  a list can contain other lists.\n\n::: {.cell}\n\n```{.r .cell-code}\nl3 <- list(list(list(1)))\nstr(l3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 1\n $ :List of 1\n  ..$ :List of 1\n  .. ..$ : num 1\n```\n\n\n:::\n:::\n\n\\placefig{10}{4}{width=5cm,height=20cm}{../diagrams/vectors/list-recursive.png}\n\n## Lists\n\n* `c()` will combine several lists into one.\n\n\\fontsize{9}{9}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nl4 <- list(list(1, 2), c(3, 4))\nl5 <- c(list(1, 2), c(3, 4))\nstr(l4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ :List of 2\n  ..$ : num 1\n  ..$ : num 2\n $ : num [1:2] 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(l5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ : num 1\n $ : num 2\n $ : num 3\n $ : num 4\n```\n\n\n:::\n:::\n\n\\placefig{10}{3}{width=5cm,height=20cm}{../diagrams/vectors/list-c.png}\n\n## Testing and coercion {#list-types}\n\n\\fontsize{9}{9}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nas.list(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n```\n\n\n:::\n:::\n\n\\fontsize{13}{14}\\sf\n\n* You can turn a list into an atomic vector with `unlist()`.\n\n## Data frames and tibbles {#tibble}\n\n\\placefig{12}{0.5}{width=3cm,height=20cm}{../diagrams/vectors/summary-tree-s3-2.png}\n\n* Most important S3 vectors built on lists:\\newline data frames and tibbles.\n\n\\fontsize{10}{8}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- data.frame(x = 1:3, y = letters[1:3])\ntypeof(df1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(df1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$names\n[1] \"x\" \"y\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\\placefig{10}{4.1}{width=5cm}{../diagrams/vectors/data-frame-1.png}\n\n\\placefig{7}{6}{width=5cm}{../diagrams/vectors/data-frame-2.png}\n\n\n## Data frames and tibbles\n\n* A data frame has a constraint: the length of each of its vectors must be the same.\n* A data frame has `rownames()` and `colnames()`. The `names()`\n  of a data frame are the column names.\n* A data frame has `nrow()` rows and `ncol()` columns. The `length()` of a\n  data frame gives the number of columns.\n\n## Tibbles\n\\fontsize{13}{14}\\sf\n\n* Modern reimagining of the data frame.\n* tibbles are \"lazy and surly\": they do less and complain more.\n\n\\fontsize{10}{8}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tibble)\ndf2 <- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(df2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$class\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n$row.names\n[1] 1 2 3\n\n$names\n[1] \"x\" \"y\"\n```\n\n\n:::\n:::\n\n\n## Creating data frames and tibbles\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(data.frame(`1` = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"X1\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(tibble(`1` = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\"\n```\n\n\n:::\n:::\n\n## Creating data frames and tibbles\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(x = 1:4, y = 1:2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y\n1 1 1\n2 2 2\n3 3 1\n4 4 2\n```\n\n\n:::\n\n```{.r .cell-code}\ntibble(x = 1:4, y = 1:2)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `tibble()`:\n! Tibble columns must have compatible sizes.\n* Size 4: Existing data.\n* Size 2: Column `y`.\ni Only values of size one are recycled.\n```\n\n\n:::\n:::\n\n## Creating data frames and tibbles\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  x = 1:3,\n  y = x * 2,\n  z = 5\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n      x     y     z\n  <int> <dbl> <dbl>\n1     1     2     5\n2     2     4     5\n3     3     6     5\n```\n\n\n:::\n:::\n\n\n## Row names {#rownames}\n\nData frames allow you to label each row with a name, a character vector containing only unique values:\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ndf3 <- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      age  hair\nBob    35 blond\nSusan  27 brown\nSam    18 black\n```\n\n\n:::\n:::\n\n## Row names\n\n* tibbles do not support row names\n* convert row names into a regular column with either `rownames_to_column()`, or the `rownames` argument:\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nas_tibble(df3, rownames = \"name\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n  name    age hair \n  <chr> <dbl> <chr>\n1 Bob      35 blond\n2 Susan    27 brown\n3 Sam      18 black\n```\n\n\n:::\n:::\n\n## Printing\n\n\\fontsize{10}{9.5}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::starwars\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 87 x 14\n   name       height  mass hair_color skin_color eye_color birth_year sex  \n   <chr>       <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr>\n 1 Luke Skyw~    172    77 blond      fair       blue            19   male \n 2 C-3PO         167    75 <NA>       gold       yellow         112   none \n 3 R2-D2          96    32 <NA>       white, bl~ red             33   none \n 4 Darth Vad~    202   136 none       white      yellow          41.9 male \n 5 Leia Orga~    150    49 brown      light      brown           19   fema~\n 6 Owen Lars     178   120 brown, gr~ light      blue            52   male \n 7 Beru Whit~    165    75 brown      light      blue            47   fema~\n 8 R5-D4          97    32 <NA>       white, red red             NA   none \n 9 Biggs Dar~    183    84 black      light      brown           24   male \n10 Obi-Wan K~    182    77 auburn, w~ fair       blue-gray       57   male \n# i 77 more rows\n# i 6 more variables: gender <chr>, homeworld <chr>, species <chr>,\n#   films <list>, vehicles <list>, starships <list>\n```\n\n\n:::\n:::\n\n## Printing\n\n* Tibbles only show first 10 rows and all columns that fit on\n  screen. Additional columns shown at bottom.\n* Each column labelled with its type, abbreviated to 3--4 letters.\n* Wide columns truncated.\n\n## List columns\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:3)\ndf$y <- list(1:2, 1:3, 1:4)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(\n  x = 1:3,\n  y = I(list(1:2, 1:3, 1:4))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x          y\n1 1       1, 2\n2 2    1, 2, 3\n3 3 1, 2, 3, 4\n```\n\n\n:::\n:::\n\n\\placefig{10}{1.5}{width=5cm,height=20cm}{../diagrams/vectors/data-frame-list.png}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  x = 1:3,\n  y = list(1:2, 1:3, 1:4)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 2\n      x y        \n  <int> <list>   \n1     1 <int [2]>\n2     2 <int [3]>\n3     3 <int [4]>\n```\n\n\n:::\n:::\n\n## Matrix and data frame columns\n\n::: {.cell}\n\n```{.r .cell-code}\ndfm <- tibble(\n  x = 1:3 * 10,\n  y = matrix(1:9, nrow = 3),\n  z = data.frame(a = 3:1, b = letters[1:3])\n)\nstr(dfm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [3 x 3] (S3: tbl_df/tbl/data.frame)\n $ x: num [1:3] 10 20 30\n $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n $ z:'data.frame':\t3 obs. of  2 variables:\n  ..$ a: int [1:3] 3 2 1\n  ..$ b: chr [1:3] \"a\" \"b\" \"c\"\n```\n\n\n:::\n:::\n\n\\placefig{10}{1.25}{width=5cm,height=20cm}{../diagrams/vectors/data-frame-matrix.png}\n\n## Exercises\n\n13.  Can you have a data frame with zero rows? What about zero columns?\n14.  What happens if you attempt to set rownames that are not unique?\n15.  If `df` is a data frame, what can you say about `t(df)`, and `t(t(df))`?\n    Perform some experiments, making sure to try different column types.\n16.  What does `as.matrix()` do when applied to a data frame with\n    columns of different types? How does it differ from `data.matrix()`?\n\n## `NULL`\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\nYou can test for `NULL`s with `is.null()`:\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- NULL\nx == NULL\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlogical(0)\n```\n\n\n:::\n\n```{.r .cell-code}\nis.null(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}