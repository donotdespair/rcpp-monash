{
  "hash": "f1532700440bff80597b78d2b482bd2a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: ETC4500/ETC5450 Advanced&nbsp;R&nbsp;programming\nauthor: \"Week 2: Foundations of R programming\"\nformat:\n  presentation-beamer:\n    fontsize: \"14pt,t\"\n    section-titles: false\n    knitr:\n      opts_chunk:\n        dev: \"cairo_pdf\"\n    fig-width: 7.5\n    fig-height: 3.5\n    include-in-header: ../header.tex\n    keep-tex: false\n---\n\n\n\n## Outline\n\n\\vspace*{0.4cm}\n\\tableofcontents\n\n# Subsetting\n\n## Exercises\n\n1. What is the result of subsetting a vector with positive integers, negative integers, a logical vector, or a character vector?\n2. What's the difference between `[`, `[[`, and `$` when applied to a list?\n3. When should you use `drop = FALSE`?\n\n## Exercises\n\\fontsize{13}{14}\\sf\n\n4. Fix each of the following common data frame subsetting errors:\n\n   ::: {.cell}\n   \n   ```{.r .cell-code}\n   mtcars[mtcars$cyl = 4, ]\n   mtcars[-1:4, ]\n   mtcars[mtcars$cyl <= 5]\n   mtcars[mtcars$cyl == 4 | 6, ]\n   ```\n   :::\n\n5. Extract the residual degrees of freedom from `mod`\n\n   ::: {.cell}\n   \n   ```{.r .cell-code}\n   mod <- lm(mpg ~ wt, data = mtcars)\n   ```\n   :::\n\n6. Extract the R squared from the model summary (`summary(mod)`)\n\n## Exercises\n\n7. How would you randomly permute the columns of a data frame?\n8. Can you simultaneously permute the rows and columns in one step?\n9. How would you select a random sample of m rows from a data frame? What if the sample had to be contiguous (i.e., with an initial row, a final row, and every row in between)?\n10. How could you put the columns in a data frame in alphabetical order?\n\n# Control flow\n## Exercises\n\n11. What is the difference between `if` and `ifelse()` and `dplyr::if_else()`?\n\n12. What type of vector does each of the following calls to `ifelse()` return?\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ifelse(TRUE, 1, \"no\")\n    ifelse(FALSE, 1, \"no\")\n    ifelse(NA, 1, \"no\")\n    ```\n    :::\n\n## Exercises\n\n13. Why does the following code work?\\fontsize{10}{10}\\sf\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- 1:10\n    if (length(x)) \"not empty\" else \"empty\"\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"not empty\"\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    x <- numeric()\n    if (length(x)) \"not empty\" else \"empty\"\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"empty\"\n    ```\n    \n    \n    :::\n    :::\n\n# Functions\n\n## Function fundamentals\n\n* Almost all functions can be broken down into three components: arguments, body, and environment.\n\n  * The `formals()`, the list of arguments that control how you call the function.\n  * The `body()`, the code inside the function.\n  * The `environment()`, the data structure that determines how the function finds the values associated with the names.\n\n* Functions are objects and have attributes.\n\n## Function components\n\\fontsize{10}{5}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nf02 <- function(x, y) {\n  # A comment\n  x + y\n}\nformals(f02)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$x\n\n\n$y\n```\n\n\n:::\n\n```{.r .cell-code}\nbody(f02)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{\n    x + y\n}\n```\n\n\n:::\n\n```{.r .cell-code}\nenvironment(f02)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n## Function attributes\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(f02, \"srcref\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n:::\n\n## Invoking a function\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(1:10, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.5\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(, TRUE, x = 1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.5\n```\n\n\n:::\n\n```{.r .cell-code}\nargs <- list(1:10, na.rm = TRUE)\ndo.call(mean, args)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.5\n```\n\n\n:::\n:::\n\n## Function composition {#function-composition}\n\\fontsize{13}{15}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare <- function(x) { x^2 }\ndeviation <- function(x) { x - mean(x) }\nx <- runif(100)\n```\n:::\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\nNesting:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(mean(square(deviation(x))))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3\n```\n\n\n:::\n:::\n\nIntermediate variables:\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- deviation(x)\nout <- square(out)\nout <- mean(out)\nout <- sqrt(out)\nout\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3\n```\n\n\n:::\n:::\n:::\n\n::: {.column width=\"50%\"}\n\nPipe:\n\n::: {.cell}\n\n```{.r .cell-code}\nx |>\n  deviation() |>\n  square() |>\n  mean() |>\n  sqrt()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3\n```\n\n\n:::\n:::\n\n:::\n::::\n\n## Lexical scoping {#lexical-scoping}\n\nNames defined inside a function mask names defined outside a function.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10\ny <- 20\ng02 <- function() {\n  x <- 1\n  y <- 2\n  c(x, y)\n}\ng02()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2\n```\n\n\n:::\n:::\n\n## Lexical scoping\n\nNames defined inside a function mask names defined outside a function.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2\ng03 <- function() {\n  y <- 1\n  c(x, y)\n}\ng03()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 1\n```\n\n\n:::\n\n```{.r .cell-code}\n# And this doesn't change the previous value of y\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n:::\n\n## Lexical scoping\n\nNames defined inside a function mask names defined outside a function.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1\ng04 <- function() {\n  y <- 2\n  i <- function() {\n    z <- 3\n    c(x, y, z)\n  }\n  i()\n}\ng04()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n## Functions versus variables\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ng07 <- function(x) { x + 1 }\ng08 <- function() {\n  g07 <- function(x) { x + 100 }\n  g07(10)\n}\ng08()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 110\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ng09 <- function(x) { x + 100 }\ng10 <- function() {\n  g09 <- 10\n  g09(g09)\n}\ng10()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 110\n```\n\n\n:::\n:::\n\n\n## A fresh start {#fresh-start}\n\nWhat happens to values between invocations of a function?\n\n::: {.cell}\n\n:::\n\n\\fontsize{10}{9}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng11 <- function() {\n  if (!exists(\"a\")) {\n    a <- 1\n  } else {\n    a <- a + 1\n  }\n  a\n}\n\ng11()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\ng11()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n## Dynamic lookup\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ng12 <- function() { x + 1 }\nx <- 15\ng12()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- 20\ng12()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncodetools::findGlobals(g12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"{\" \"+\" \"x\"\n```\n\n\n:::\n:::\n\n\\pause\\alert{It is good practice to pass all the inputs to a function as arguments.}\n\n## Lazy evaluation {#lazy-evaluation}\n\nThis code doesn't generate an error because `x` is never used:\n\n::: {.cell}\n\n```{.r .cell-code}\nh01 <- function(x) {\n  10\n}\nh01(stop(\"This is an error!\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n## Promises\n\\fontsize{13}{14}\\sf\n\nLazy evaluation is powered by a data structure called a __promise__.\n\nA promise has three components:\n\n*   An expression, like `x + y`, which gives rise to the delayed computation.\n\n*   An environment where the expression should be evaluated\n\n*   A value, which is computed and cached the first time a promise is\n    accessed when the expression is evaluated in the specified environment.\n\n## Promises\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 10\nh02 <- function(x) {\n  y <- 100\n  x + 1\n}\nh02(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n:::\n\n## Promises\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ndouble <- function(x) {\n  message(\"Calculating...\")\n  x * 2\n}\nh03 <- function(x) {\n  c(x, x)\n}\nh03(double(20))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCalculating...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 40 40\n```\n\n\n:::\n:::\n\n\\pause\\fontsize{13}{15}\\sf\n\nPromises are like a quantum state: any attempt to inspect them with R code will force an immediate evaluation, making the promise disappear.\n\n## Default arguments\n\nThanks to lazy evaluation, default values can be defined in terms of other arguments, or even in terms of variables defined later in the function:\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nh04 <- function(x = 1, y = x * 2, z = a + b) {\n  a <- 10\n  b <- 100\n  c(x, y, z)\n}\nh04()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   1   2 110\n```\n\n\n:::\n:::\n\n\\pause\\alert{Not recommended!}\n\n## Exercises\n\n14. In `hist()`, the default value of `xlim` is `range(breaks)`, the default\n    value for `breaks` is `\"Sturges\"`, and\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    range(\"Sturges\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"Sturges\" \"Sturges\"\n    ```\n    \n    \n    :::\n    :::\n\n    Explain how `hist()` works to get a correct `xlim` value.\n\n## Exercises\n\n15. Explain why this function works. Why is it confusing?\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    show_time <- function(x = stop(\"Error!\")) {\n      stop <- function(...) Sys.time()\n      print(x)\n    }\n    show_time()\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"2025-02-03 15:35:25 AEDT\"\n    ```\n    \n    \n    :::\n    :::\n\n## `...`  (dot-dot-dot) {#fun-dot-dot-dot}\n\nAllows for any number of additional arguments.\n\nYou can use `...` to pass additional arguments to another function.\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ni01 <- function(y, z) {\n  list(y = y, z = z)\n}\ni02 <- function(x, ...) {\n  i01(...)\n}\nstr(i02(x = 1, y = 2, z = 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ y: num 2\n $ z: num 3\n```\n\n\n:::\n:::\n\n## `...`  (dot-dot-dot)\n\n`list(...)` evaluates the arguments and stores them in a list:\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni04 <- function(...) {\n  list(...)\n}\nstr(i04(a = 1, b = 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ a: num 1\n $ b: num 2\n```\n\n\n:::\n:::\n\n## `...`  (dot-dot-dot)\n\\fontsize{13}{14}\\sf\n\n*   Allows you to pass arguments to a function called within your function, without having to list them all explicitly.\n\n\\pause\\alert{Two downsides:}\n\n*   When you use it to pass arguments to another function, you have to\n    carefully explain to the user where those arguments go.\n*   A misspelled argument will not raise an error. This makes it easy for\n    typos to go unnoticed:\n\n\\fontsize{10}{5}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(1, 2, NA, na_rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n## Exercises\n\n16. Explain the following results: \\fontsize{10}{10}\\sf\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    sum(1, 2, 3)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 6\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    mean(1, 2, 3)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    sum(1, 2, 3, na.omit = TRUE)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 7\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    mean(1, 2, 3, na.omit = TRUE)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1\n    ```\n    \n    \n    :::\n    :::\n\n\n## Exiting a function\n\nMost functions exit in one of two ways:\n\n* return a value, indicating success\n* throw an error, indicating failure.\n\n## Implicit versus explicit returns\n\nImplicit return, where the last evaluated expression is the return value:\n\n\\fontsize{10}{5}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nj01 <- function(x) {\n  if (x < 10) {\n    0\n  } else {\n    10\n  }\n}\nj01(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\nj01(15)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n## Implicit versus explicit returns\n\nExplicit return, by calling `return()`:\n\n\\fontsize{10}{5}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nj02 <- function(x) {\n  if (x < 10) {\n    return(0)\n  } else {\n    return(10)\n  }\n}\nj02(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\nj02(15)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n## Invisible values {#invisible}\n\nMost functions return visibly: calling the function in an interactive context prints the result.\n\n::: {.cell}\n\n```{.r .cell-code}\nj03 <- function() { 1 }\nj03()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\nHowever, you can prevent automatic printing by applying `invisible()` to the last value:\n\n::: {.cell}\n\n```{.r .cell-code}\nj04 <- function() { invisible(1) }\nj04()\n```\n:::\n\n## Invisible values {#invisible}\n\nThe most common function that returns invisibly is `<-`:\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 2\n(a <- 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\nThis is what makes it possible to chain assignments:\n\n::: {.cell}\n\n```{.r .cell-code}\na <- b <- c <- d <- 2\n```\n:::\n\nIn general, any function called primarily for a side effect (like `<-`, `print()`, or `plot()`) should return an invisible value (typically the value of the first argument).\n\n## Errors\n\nIf a function cannot complete its assigned task, it should throw an error with `stop()`, which immediately terminates the execution of the function.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nj05 <- function() {\n  stop(\"I'm an error\")\n  return(10)\n}\nj05()\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in j05(): I'm an error\n```\n\n\n:::\n:::\n\n## Exit handlers {#on-exit}\n\\fontsize{10}{10}\\sf\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nj06 <- function(x) {\n  cat(\"Hello\\n\")\n  on.exit(cat(\"Goodbye!\\n\"), add = TRUE)\n  if (x) {\n    return(10)\n  } else {\n    stop(\"Error\")\n  }\n}\n```\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nj06(TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello\nGoodbye!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\nj06(FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello\n```\n\n\n:::\n\n::: {.cell-output .cell-output-error}\n\n```\nError in j06(FALSE): Error\n```\n\n\n:::\n:::\n\n:::\n::::\n\n## Exit handlers\n\n`on.exit()` allows you to add clean-up code\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nwith_dir <- function(dir, code) {\n  old <- setwd(dir)\n  on.exit(setwd(old), add = TRUE)\n  code\n}\ngetwd()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"/home/hyndman/git/Teaching/arp/week2\"\n```\n\n\n:::\n\n```{.r .cell-code}\nwith_dir(\"~\", getwd())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"/home/hyndman\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngetwd()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"/home/hyndman/git/Teaching/arp/week2\"\n```\n\n\n:::\n:::\n\n## Function forms\n\n###\n> To understand computations in R, two slogans are helpful:\n>\n> * Everything that exists is an object.\n> * Everything that happens is a function call.\n>\n> --- John Chambers\n\n## Function forms\n\n* __prefix__: the function name comes before its arguments, like\n  `foofy(a, b, c)`.\n* __infix__: the function name comes in between its arguments, like\n  `x + y`.\n* __replacement__: functions that replace values by assignment, like\n  `names(df) <- c(\"a\", \"b\", \"c\")`.\n* __special__: functions like `[[`, `if`, and `for`.\n\n## Rewriting to prefix form {#prefix-transform}\n\nEverything can be written in prefix form.\n\n::: {.cell}\n\n```{.r .cell-code}\nx + y\n`+`(x, y)\n\nnames(df) <- c(\"x\", \"y\", \"z\")\n`names<-`(df, c(\"x\", \"y\", \"z\"))\n\nfor(i in 1:10) print(i)\n`for`(i, 1:10, print(i))\n```\n:::\n\n## Don't be evil!\n\n::: {.cell}\n\n```{.r .cell-code}\n`(` <- function(e1) {\n  if (is.numeric(e1) && runif(1) < 0.1) {\n    e1 + 1\n  } else {\n    e1\n  }\n}\nreplicate(50, (1 + 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 4 3 3 3 4 3 4 4 3 3 3 3 3 4 3 3 3 4 3 3\n[36] 3 4 3 3 3 4 3 3 3 3 3 3 3 3 3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n:::\n\n## Prefix form {#prefix-form}\n\nYou can specify arguments in three ways:\n\n* By position, like `help(mean)`.\n* By name, like `help(topic = mean)`.\n* Using partial matching, like `help(top = mean)`.\n\n## Exercises\n\n17. Clarify the following list of odd function calls:\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- sample(replace = TRUE, 20, x = c(1:10, NA))\n    y <- runif(min = 0, max = 1, 20)\n    cor(m = \"k\", y = y, u = \"p\", x = x)\n    ```\n    :::\n\n## Infix functions\n\nFunctions with 2 arguments, and the function name comes between the arguments:\n\n `:`, `::`, `:::`, `$`, `@`, `^`, `*`, `/`, `+`, `-`, `>`, `>=`, `<`, `<=`, `==`, `!=`, `!`, `&`, `&&`, `|`, `||`, `~`, `<-`, and `<<-`.\n\n::: {.cell}\n\n```{.r .cell-code}\n1 + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n`+`(1, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n## Infix functions\n\nYou can also create your own infix functions that start and end with `%`.\n\n::: {.cell}\n\n```{.r .cell-code}\n`%+%` <- function(a, b) paste0(a, b)\n\"new \" %+% \"string\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"new string\"\n```\n\n\n:::\n:::\n\n## Replacement functions {#replacement-functions}\n\n* Replacement functions act like they modify their arguments in place, and have the special name `xxx<-`.\n* They must have arguments named `x` and `value`, and must return the modified object.\n\n::: {.cell}\n\n```{.r .cell-code}\n`second<-` <- function(x, value) {\n  x[2] <- value\n  x\n}\nx <- 1:10\nsecond(x) <- 5L\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  5  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n## Replacement functions\n\n::: {.cell}\n\n```{.r .cell-code}\n`modify<-` <- function(x, position, value) {\n  x[position] <- value\n  x\n}\nmodify(x, 1) <- 10\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 10  5  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\nWhen you write `modify(x, 1) <- 10`, behind the scenes R turns it into:\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- `modify<-`(x, 1, 10)\n```\n:::\n\n# Environments\n\n## Environment basics\n\nEnvironments are data structures that power scoping.\n\nAn environment is similar to a named list, with four important exceptions:\n\n* Every name must be unique.\n* The names in an environment are not ordered.\n* An environment has a parent.\n* Environments are not copied when modified.\n\n## Environment basics\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rlang)\ne1 <- env(\n  a = FALSE,\n  b = \"a\",\n  c = 2.3,\n  d = 1:3,\n)\n```\n:::\n\n\\placefig{8}{1.9}{width=7cm}{../diagrams/environments/bindings.png}\n\n### Special environments\n\n* The **current environment** is the environment in which code is currently executing.\n* The **global environment** is where all interactive computation takes place. Your \"workspace\".\n\n## Parent environments\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n* Every environment has a parent.\n* If a name is not found in an environment, R looks in the parent environment.\n* The ancestors of the global environment include every attached package.\n\n:::\n::: {.column width=\"50%\"}\n\\fontsize{10}{10}\\sf\\vspace*{-0.3cm}\n\n::: {.cell}\n\n```{.r .cell-code}\nenv_parents(e1, last = empty_env())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [[1]] $ <env: global>\n [[2]] $ <env: package:rlang>\n [[3]] $ <env: package:dplyr>\n [[4]] $ <env: package:stats>\n [[5]] $ <env: package:graphics>\n [[6]] $ <env: package:grDevices>\n [[7]] $ <env: package:datasets>\n [[8]] $ <env: renv:shims>\n [[9]] $ <env: package:utils>\n[[10]] $ <env: package:methods>\n[[11]] $ <env: Autoloads>\n[[12]] $ <env: package:base>\n[[13]] $ <env: empty>\n```\n\n\n:::\n:::\n:::\n::::\n\n## Super assignment\n\n* Regular assignment (`<-`) creates a variable in the current environment.\n* Super assignment (`<<-`) modifies a variable in a parent environment.\n* If it can't find an existing variable, it creates one in the global environment.\n\n## Package environments\n\\fontsize{13}{15}\\sf\n\n* Every package attached becomes one of the parents of the global environment (in order of attachment).\\fontsize{10}{10}\\sf\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  search()\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n   [1] \".GlobalEnv\"        \"package:rlang\"     \"package:dplyr\"    \n   [4] \"package:stats\"     \"package:graphics\"  \"package:grDevices\"\n   [7] \"package:datasets\"  \"renv:shims\"        \"package:utils\"    \n  [10] \"package:methods\"   \"Autoloads\"         \"package:base\"     \n  ```\n  \n  \n  :::\n  :::\n\n\\fontsize{13}{15}\\sf\n\n* Attaching a package changes the parent of the global environment.\n* `Autoloads` uses delayed bindings to save memory by only loading package objects when needed.\n\n## Function environments\n\\fontsize{13}{14}\\sf\n\nA function binds the current environment when it is created.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 1\nf <- function(x) {\n  env_print(current_env())\n  x + y\n}\nf(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: 0x62644802fae0>\nParent: <environment: global>\nBindings:\n* x: <lazy>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n## Namespaces\n\\fontsize{13}{14}\\sf\n\n* Package environment: how an R user finds a function in an attached package (only includes exports)\n* Namespace environment: how a package finds its own objects (includes non-exports as well)\n* Each namespace environment has an imports environment (controlled via NAMESPACE file).\n\n::: {.cell}\n::: {.cell-output-display}\n![](../diagrams/environments/namespace-env.png){width=4.13in}\n:::\n:::\n\n## Caller environments\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) {\n  g(x = 2)\n}\ng <- function(x) {\n  h(x = 3)\n}\nh <- function(x) {\n  stop()\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nf(x = 1)\n#> Error: in h(x = 3)\ntraceback()\n#> 4: stop() at #3\n#> 3: h(x = 3) at #3\n#> 2: g(x = 2) at #3\n#> 1: f(x = 1)\n```\n:::\n\n## Lazy evaluation\n\n::: {.cell}\n\n```{.r .cell-code}\na <- function(x) b(x)\nb <- function(x) c(x)\nc <- function(x) x\na(f())\n#> Error: in h(x = 3)\ntraceback()\n#> 7: stop() at #3\n#> 6: h(x = 3) at #3\n#> 5: g(x = 2) at #3\n#> 4: f() at #1\n#> 3: c(x) at #1\n#> 2: b(x) at #1\n#> 1: a(f())\nunused argument (clas\n```\n:::\n\n\n# Conditions\n\n## Conditions\n\n```r\nmessage(\"This is what a message looks like\")\n#> This is what a message looks like\n\nwarning(\"This is what a warning looks like\")\n#> Warning: This is what a warning looks like\n\nstop(\"This is what an error looks like\")\n#> Error in eval(expr, envir, enclos): This is what an error looks like\n```\n\n\\pause\n\n* Ignore messages with `suppressMessages()`.\n* Ignore warnings with `suppressWarnings()`.\n* Ignore errors with `try()`.\n\n## try()\n\n* Allows execution to continue even if an error occurs.\n* Returns a special object that captures the error.\n\n\\fontsize{10}{10}\\sf\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nf1 <- function(x) {\n  log(x)\n  10\n}\nf1(\"x\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in log(x): non-numeric argument to mathematical function\n```\n\n\n:::\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nf2 <- function(x) {\n  try(log(x))\n  10\n}\nf2(\"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in log(x) : non-numeric argument to mathematical function\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n:::\n::::\n\n## Handling conditions\n\\fontsize{13}{15}\\sf\n\nAllow you to specify what should happen when a condition occurs.\n\n::: {.cell}\n\n```{.r .cell-code}\ntryCatch(\n  error = function(cnd) {\n    # code to run when error is thrown\n  },\n  code_to_run_while_handlers_are_active\n)\nwithCallingHandlers(\n  warning = function(cnd) {\n    # code to run when warning is signalled\n  },\n  message = function(cnd) {\n    # code to run when message is signalled\n  },\n  code_to_run_while_handlers_are_active\n)\n```\n:::\n\n## tryCatch()\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nf3 <- function(x) {\n  tryCatch(\n    error = function(cnd) NA,\n    log(x)\n  )\n}\n\nf3(\"x\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n## withCallingHandlers()\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nf4 <- function(x) {\n  withCallingHandlers(\n    warning = function(cnd) cat(\"How did this happen?\\n\"),\n    log(x)\n  )\n}\n\nf4(-1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHow did this happen?\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n:::\n\n\n## Exercise\n\nExplain the results of running the following code\n\n::: {.cell}\n\n```{.r .cell-code}\nshow_condition <- function(code) {\n  tryCatch(\n    error = function(cnd) \"error\",\n    warning = function(cnd) \"warning\",\n    message = function(cnd) \"message\",\n    {\n      code\n      5\n    }\n  )\n}\nshow_condition(stop(\"!\"))\nshow_condition(10)\nshow_condition(warning(\"?!\"))\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}